package rhcve

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

const hydraUrl string = "https://access.redhat.com/hydra/rest/securitydata/cve/"
const pyxisUrl string = "https://catalog.redhat.com/api/containers/v1/images/nvr/"

type CVE struct {
	ID              string
	Description     string
	CWEs            []string
	FixedInVersions []string
	OWASPTop25      bool
	RHKnown         bool
	AffectedState   string
	Advisories      []string
}

type PackageState struct {
	CPE      string `json:"cpe"`
	FixState string `json:"fix_state"`
	Name     string `json:"package_name"`
}

type Advisory struct {
	ProductName string `json:"product_name"`
	ID          string `json:"advisory"`
	CPE         string `json:"cpe"`
	Package     string `json:"package"`
}

type PyxisContainerResult struct {
	Data []PyxisResult `json:"data"`
}
type PyxisResult struct {
	Repositories []Repository `json:"repositories"`
}

type Repository struct {
	Name string `json:"repository"`
}

type RHCVE struct {
	Name             string         `json:"name"`
	ThreatSeverity   string         `json:"thread_severity"`
	CVSS3            CVSSv3         `json:"cvss3"`
	Details          string         `json:"details"`
	Statement        string         `json:"statement"`
	AffectedReleases []Advisory     `json:"affected_release,omitempty"`
	PackageStates    []PackageState `json:"package_state"`
}

type CVSSv3 struct {
	BaseScore string `json:"cvss3_base_score"`
	Vector    string `json:"cvss3_scoring_vector"`
	Status    string `json:"verified"`
}

// From https://www.thegreatcodeadventure.com/mocking-http-requests-in-golang/
// Allows mocking of HTTP calls to goCveUrl in tests
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

var (
	Client HTTPClient
)

// called once on import of package
func init() {
	Client = &http.Client{}
}

func NewCVE(id string) (cve CVE) {
	return CVE{ID: id}
}

//curl -s "https://catalog.redhat.com/api/containers/v1/images/nvr/$BUILD?page_size=1&page=0" | jq .data[].repositories[].repository
func GetContainerRepos(nvr string) ([]string, error) {
	repos := make([]string, 0)
	if !strings.Contains(nvr, "-container-") {
		fmt.Printf("Tried to get container repo for non container build: %v", nvr)
		return append(repos, nvr), nil
	}
	url := hydraUrl + nvr
	request, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	response, err := Client.Do(request)
	if err != nil {
		return nil, err
	}
	var result PyxisContainerResult
	json.NewDecoder(response.Body).Decode(&result)
	for _, d := range result.Data {
		for _, repo := range d.Repositories {
			repos = append(repos, repo.Name)
		}
	}
	return repos, nil
}

// Won't be able to get impact override on affects until this is fixed: UNIFIED-7423
// Can get it on cvemap.xml in the meantime: https://www.redhat.com/security/data/metrics/cvemap.xml
func CheckRHCVE(cve *CVE, cpe string, nvr string) error {
	var err error
	if !strings.HasPrefix(cve.ID, "CVE-") {
		return fmt.Errorf("Invalid CVE identifier: %v\n", cve.ID)
	}
	url := hydraUrl + cve.ID + ".json"
	var request *http.Request
	request, err = http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	var response *http.Response
	response, err = Client.Do(request)
	if err != nil {
		return err
	}
	if response.StatusCode == 404 {
		return nil
	} else if response.StatusCode == 200 {
		cve.RHKnown = true
	}
	var rhCveResults RHCVE
	json.NewDecoder(response.Body).Decode(&rhCveResults)
	checkAffectedState(rhCveResults, cve, cpe, nvr)
	checkAdvisories(cve, rhCveResults.AffectedReleases, cpe)
	return nil
}

// cvemap.xml has a bug that means advisory packages are not correct for containers: PSDEVOPS-2148
// In the meantime only collect a list of advisories ID which are related to this CVE by cpe
// If that is fixed we could provide a more precise mapping between product/build and advisories
func checkAdvisories(cve *CVE, advisories []Advisory, cpe string) {
	hasCpePrefixTest := func(s string) bool { return strings.HasPrefix(s, cpe) }
	cpeAdvisories := filterAffected(advisories, hasCpePrefixTest)
	if len(cpeAdvisories) > 0 {
		results := make([]string, 0)
		for _, advisory := range cpeAdvisories {
			results = append(results, advisory.ID)
		}
		cve.Advisories = results
	}
}

func checkAffectedState(rhCveResults RHCVE, cve *CVE, cpe string, nvr string) {
	var repos []string
	var err error
	if isContainerNvr(nvr) {
		repos, err = GetContainerRepos(nvr)
		if err != nil {
			fmt.Println("Unable to get container repo for nvr %v. "+
				"can't set RH affected state because of error: %v", nvr, err)
		}
	}
	hasCpePrefixTest := func(s string) bool { return strings.HasPrefix(s, cpe) }
	cpePackages := filterPackages(rhCveResults.PackageStates, hasCpePrefixTest)
	if len(cpePackages) == 1 {
		cve.AffectedState = cpePackages[0].FixState
	} else {
		// if multipe matching cpes are found, need to also check the package name
		// here we only have a build name, if it's a container, lookup the container repo as used in Hydra API
		for _, p := range cpePackages {
			if isContainerNvr(nvr) {
				if contains(repos, p.Name) {
					fmt.Printf("Setting Affected state to %v", p.FixState)
					cve.AffectedState = p.FixState
				}
			} else { //non container build
				if nvr == p.Name {
					fmt.Printf("Setting Affected state to %v", p.FixState)
					cve.AffectedState = p.FixState
				}
			}
		}
	}
}

func isContainerNvr(nvr string) bool {
	return strings.Contains(nvr, "-container-")
}

func contains(ss []string, value string) bool {
	for _, s := range ss {
		if s == value {
			return true
		}
	}
	return false
}

func filterAffected(a []Advisory, test func(string) bool) (ret []Advisory) {
	for _, state := range a {
		if test(state.CPE) {
			ret = append(ret, state)
		}
	}
	return
}

func filterPackages(ps []PackageState, test func(string) bool) (ret []PackageState) {
	for _, state := range ps {
		if test(state.CPE) {
			ret = append(ret, state)
		}
	}
	return
}
