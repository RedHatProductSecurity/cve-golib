package rhcve

import (
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"strings"
)

const hydraUrl string = "https://access.redhat.com/hydra/rest/securitydata/cve/"
const pyxisUrl string = "https://catalog.redhat.com/api/"
const bzUrl string = "https://bugzilla.redhat.com/rest/bug/"
const containerRegex string = `-container(-v[0-9\.]+)`
const usEnglish string = "en:us"

type CVE struct {
	ID      string
	Package string
	//TODO make this an int/iota/enum and parse impacts like 'high' as 'important'
	Impact          string
	Description     string
	CWEs            []string
	FixedInVersions []string
	OWASPTop25      bool
	RHKnown         bool
	RHImpact        ImpactValue
	CVSSv3          string
	BugzillaID      string
	Statement       string
	Components      map[string]ComponentState
	Mitigation      string
}

// TODO make the key a combination of cpe and packageName to support multiple cpe states, one for each component?
// Alternative is to try and come up with a aggregate some how with compares Advisories and PackageStates to form a
// summary of a product for each CVE
func (cve *CVE) MakeComponent(cpe string) {
	_, exists := cve.Components[cpe]
	if exists {
		return
	}
	cve.Components = make(map[string]ComponentState, 1)
	cve.Components[cpe] = ComponentState{}
}

type ComponentState struct {
	AffectedState string
	Advisories    []string
	Impact        ImpactValue
}

type PackageState struct {
	CPE      string `json:"cpe"`
	FixState string `json:"fix_state"`
	Name     string `json:"package_name"`
	Impact   string `json:"impact"`
}

type Advisory struct {
	ProductName string `json:"product_name"`
	ID          string `json:"advisory"`
	CPE         string `json:"cpe"`
	Package     string `json:"package"`
}

type PyxisContainerResult struct {
	Data []PyxisResult `json:"data"`
}
type PyxisResult struct {
	Repositories []Repository `json:"repositories"`
}

type Repository struct {
	Name string `json:"repository"`
}

type PyxisRepositoryProductListingResult struct {
	Data []ProductListing `json:"data"`
}

type ProductListing struct {
	Name string `json:"name"`
}

type CVSSv3 struct {
	BaseScore string `json:"cvss3_base_score"`
	Vector    string `json:"cvss3_scoring_vector"`
	Status    string `json:"verified"`
}

type RHCVE struct {
	Name             string         `json:"name"`
	ThreatSeverity   string         `json:"threat_severity"`
	CVSS3            CVSSv3         `json:"cvss3"`
	Details          string         `json:"details"`
	Statement        string         `json:"statement"`
	AffectedReleases []Advisory     `json:"affected_release,omitempty"`
	PackageStates    []PackageState `json:"package_state"`
	Bugzilla         Bugzilla       `json:"bugzilla"`
	Mitigation       Mitigation     `json:"mitigation"`
}

type Bugzilla struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	URL         string `json:"url"`
}

type Mitigation struct {
	Value string `json:"value"`
	Lang  string `json:"lang"`
}

type ImpactValue struct {
	Index int
	Name  string
}

type Impact struct {
	items []ImpactValue
}

func (impact Impact) Name(findIndex int) string {
	for _, item := range impact.items {
		if item.Index == findIndex {
			return item.Name
		}
	}
	return ""
}

func (impact Impact) Index(findName string) int {
	for idx, item := range impact.items {
		if findName == item.Name {
			return idx
		}
	}
	return -1
}

var ImpactValues = Impact{[]ImpactValue{{0, "critical"}, {1, "important"}, {2, "moderate"}, {3, "low"}}}

// From https://www.thegreatcodeadventure.com/mocking-http-requests-in-golang/
// Allows mocking of HTTP calls to goCveUrl in tests
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

var (
	Client HTTPClient
)

// called once on import of package
func init() {
	Client = &http.Client{}
}

func NewCVE(id string) (cve CVE) {
	return CVE{ID: id}
}

//curl -s "https://catalog.redhat.com/api/containers/v1/images/nvr/$BUILD?page_size=1&page=0" | jq .data[].repositories[].repository
func GetContainerRepos(nvr string) ([]string, error) {
	repos := make([]string, 0)
	if !strings.Contains(nvr, "-container-") {
		fmt.Printf("Tried to get container repo for non container build: %v", nvr)
		return append(repos, nvr), nil
	}
	url := pyxisUrl + "containers/v1/images/nvr/" + nvr
	request, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	response, err := Client.Do(request)
	if err != nil {
		return nil, err
	}
	var result PyxisContainerResult
	json.NewDecoder(response.Body).Decode(&result)
	for _, d := range result.Data {
		for _, repo := range d.Repositories {
			repos = append(repos, repo.Name)
		}
	}
	return repos, nil
}

func GetContainerProductName(repo string) (string, error) {
	if !strings.Contains(repo, "/") {
		return "", fmt.Errorf("Tried to get product name for invalid repo: %v", repo)
	}
	url := pyxisUrl + "repositories/registry/registry.access.redhat.com/repository/" + repo + "/product-listings"
	request, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}
	response, err := Client.Do(request)
	if err != nil {
		return "", err
	}
	var result PyxisRepositoryProductListingResult
	json.NewDecoder(response.Body).Decode(&result)
	if len(result.Data) > 2 {
		fmt.Printf("Warning, got more than 1 product listing for repo %v, only using first result", repo)
	}
	return result.Data[0].Name, nil
}

// Won't be able to get impact override on affects until this is fixed:
// https://projects.engineering.redhat.com/browse/UNIFIED-7423
// Can get it on cvemap.xml in the meantime: https://www.redhat.com/security/data/metrics/cvemap.xml
func CheckRHCVE(index int, cves []CVE, cpe string, packageName string) error {
	var err error
	if !strings.HasPrefix(cves[index].ID, "CVE-") {
		return fmt.Errorf("Invalid CVE identifier: %v\n", cves[index].ID)
	}
	url := hydraUrl + cves[index].ID + ".json"
	var request *http.Request
	request, err = http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	var response *http.Response
	response, err = Client.Do(request)
	if err != nil {
		return err
	}
	if response.StatusCode == 404 {
		return nil
	}
	cves[index].RHKnown = true
	var rhCveResults RHCVE
	json.NewDecoder(response.Body).Decode(&rhCveResults)
	err = checkImpact(&cves[index], rhCveResults.ThreatSeverity)
	if err != nil {
		return err
	}
	cves[index].CVSSv3 = rhCveResults.CVSS3.BaseScore + "/" + rhCveResults.CVSS3.Vector
	cves[index].BugzillaID = rhCveResults.Bugzilla.ID
	cves[index].Statement = rhCveResults.Statement
	mitigation := rhCveResults.Mitigation
	if mitigation != (Mitigation{}) && mitigation.Lang == usEnglish {
		cves[index].Mitigation = mitigation.Value
	}
	err = checkAffectedState(rhCveResults, &cves[index], cpe, packageName)
	if err != nil {
		return err
	}
	checkAdvisories(&cves[index], rhCveResults.AffectedReleases, cpe)
	return nil
}

func checkImpact(cve *CVE, impactValue string) error {
	impact, err := setImpact(impactValue)
	if err != nil {
		return err
	}
	cve.RHImpact = impact
	return nil
}

func setImpact(threat_severity string) (ImpactValue, error) {
	lower_threat_severity := strings.ToLower(threat_severity)
	impact_index := ImpactValues.Index(lower_threat_severity)
	if impact_index > 0 {
		return ImpactValue{
			Index: impact_index,
			Name:  lower_threat_severity,
		}, nil
	} else {
		return ImpactValue{}, fmt.Errorf("Tried to set impact to unexpected value: %v\n", lower_threat_severity)
	}
}

// cvemap.xml has a bug that means advisory packages are not correct for containers:
// https://projects.engineering.redhat.com/browse/PSDEVOPS-2148
// In the meantime only collect a list of advisories ID which are related to this CVE by cpe
// If that is fixed we could provide a more precise mapping between product/build and advisories
func checkAdvisories(cve *CVE, advisories []Advisory, cpe string) {
	hasCpePrefixTest := func(s string) bool { return strings.HasPrefix(s, cpe) }
	cpeAdvisories := filterAffected(advisories, hasCpePrefixTest)
	if len(cpeAdvisories) > 0 {
		results := make([]string, 0)
		for _, advisory := range cpeAdvisories {
			results = append(results, advisory.ID)
		}
		cve.MakeComponent(cpe)
		componentState := cve.Components[cpe]
		componentState.Advisories = results
		cve.Components[cpe] = componentState
		fmt.Printf("Setting advisories: %v\n", results)
	}
}

func checkAffectedState(rhCveResults RHCVE, cve *CVE, cpe string, packageName string) (err error) {
	hasCpePrefixTest := func(s string) bool { return strings.HasPrefix(s, cpe) }
	cpePackages := filterPackages(rhCveResults.PackageStates, hasCpePrefixTest)
	if len(cpePackages) > 0 {
		cve.MakeComponent(cpe)
	}
	if len(cpePackages) == 1 {
		componentState := cve.Components[cpe]
		componentState.AffectedState = cpePackages[0].FixState
		componentState.Impact, err = setImpact(cpePackages[0].Impact)
		if err != nil {
			return err
		}
		cve.Components[cpe] = componentState
		fmt.Printf("Setting affected state to: %v\n", cpePackages[0].FixState)
	} else {
		// if multipe matching cpes are found, need to also check the package name
		for _, p := range cpePackages {
			if packageName == p.Name {
				componentState := cve.Components[cpe]
				componentState.AffectedState = p.FixState
				componentState.Impact, err = setImpact(p.Impact)
				if err != nil {
					return err
				}
				cve.Components[cpe] = componentState
				fmt.Printf("Setting Affected state to %v\n", p.FixState)
				break
			}
		}
	}
	return nil
}

// This function will come in handy when https://projects.engineering.redhat.com/browse/PSDEVOPS-2148 is fixed
func getPackageName(nvr string) (packageName string) {
	re := regexp.MustCompile(containerRegex)
	matchIndicies := re.FindStringSubmatchIndex(nvr)
	packageName = nvr
	//Should get 2 matches, match 0 is the entire match, and match 1 is the version group
	//SubmatchIndex returns an array with start and end positions of each match hence length == 4
	if matchIndicies != nil && len(matchIndicies) == 4 {
		packageName = nvr[0:matchIndicies[2]]
	} else {
		fmt.Printf("Didn't find match for regex %v in nvr: %v, using as is.\n", containerRegex, nvr)
	}
	return
}

func isContainerNvr(nvr string) bool {
	return strings.Contains(nvr, "-container-")
}

func contains(ss []string, value string) bool {
	for _, s := range ss {
		if s == value {
			return true
		}
	}
	return false
}

func filterAffected(a []Advisory, test func(string) bool) (ret []Advisory) {
	for _, state := range a {
		if test(state.CPE) {
			ret = append(ret, state)
		}
	}
	return
}

func filterPackages(ps []PackageState, test func(string) bool) (ret []PackageState) {
	for _, state := range ps {
		if test(state.CPE) {
			ret = append(ret, state)
		}
	}
	return
}
