package rhcve

import (
	"bufio"
	"io/ioutil"
	"net/http"
	"os"
	"testing"
)

// MockClient is the mock client
type MockClient struct {
	DoFunc func(req *http.Request) (*http.Response, error)
}

var (
	// GetDoFunc fetches the mock client's `Do` func
	GetDoFunc func(req *http.Request) (*http.Response, error)
)

// Do is the mock client's `Do` func
func (m *MockClient) Do(req *http.Request) (*http.Response, error) {
	return GetDoFunc(req)
}

func init() {
	Client = &MockClient{}
}

func TestMissingRHCVE(t *testing.T) {
	GetDoFunc = func(*http.Request) (*http.Response, error) {
		return &http.Response{
			StatusCode: 404,
			Body:       nil,
		}, nil
	}
	missingCVE := "CVE-2017-16099"
	testCVE := NewCVE(missingCVE)
	err := CheckRHCVE(&testCVE, "", "")
	if err != nil {
		t.Errorf("Got error trying to test missing dependency, %v", err)
	}
	if testCVE.RHKnown == true {
		t.Error("Expected Red Hat unknown state")
	}
}

func TestModuleAffects(t *testing.T) {
	var affectsTests = []struct {
		cve           string
		cpe           string
		packageName   string
		affectedState string
	}{
		{
			"CVE-2020-36189",
			"cpe:/a:redhat:quay:3::el7",
			"quay-registry-container",
			"",
		},
		{
			"CVE-2020-36189",
			"cpe:/a:redhat:openshift:4",
			"openshift4/ose-logging-elasticsearch5",
			"Will not fix",
		},
	}

	for _, tt := range affectsTests {
		testFile := "testdata/" + tt.cve + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		testCVE := NewCVE(tt.cve)
		err = CheckRHCVE(&testCVE, tt.cpe, tt.packageName)
		if err != nil {
			t.Errorf("Got error trying to test missing dependency, %v", err)
		}
		if testCVE.AffectedState != tt.affectedState {
			t.Errorf("Expected '%v' state but got '%v'\n", tt.affectedState, testCVE.AffectedState)
		}
	}
}

func TestGetContainerReposNonContainerNvr(t *testing.T) {
	nonContainerNvr := "some-nve-1"
	result, err := GetContainerRepos(nonContainerNvr)
	if err != nil {
		t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
	}
	if len(result) != 1 {
		t.Error("expected a slice with len 1")
	}
	if result[0] != nonContainerNvr {
		t.Errorf("expected unchanged nvr got %v", result[0])
	}
}

// TODO find an example of a build which has multiple repos for testings
func TestGetContainerRepos(t *testing.T) {
	var containerRepoTests = []struct {
		nvr   string
		repos []string
	}{
		{
			"quay-registry-container-v3.4.3-1",
			[]string{"quay/quay-rhel8"},
		},
	}
	for _, tt := range containerRepoTests {
		testFile := "testdata/" + tt.nvr + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		result, err := GetContainerRepos(tt.nvr)
		if err != nil {
			t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
		}
		if len(result) == 1 && len(tt.repos) == 1 {
			if result[0] != tt.repos[0] {
				t.Errorf("expected 1 repo with value %v, but got %v", tt.repos[0], result[0])
			}
		}
	}
}
