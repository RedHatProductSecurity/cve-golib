package rhcve

import (
	"bufio"
	"bytes"
	"io/ioutil"
	"net/http"
	"os"
	"testing"
)

// MockClient is the mock client
type MockClient struct {
	DoFunc func(req *http.Request) (*http.Response, error)
}

var (
	// GetDoFunc fetches the mock client's `Do` func
	GetDoFunc func(req *http.Request) (*http.Response, error)
)

// Do is the mock client's `Do` func
func (m *MockClient) Do(req *http.Request) (*http.Response, error) {
	return GetDoFunc(req)
}

func init() {
	Client = &MockClient{}
}

func TestMissingRHCVE(t *testing.T) {
	GetDoFunc = func(*http.Request) (*http.Response, error) {
		return &http.Response{
			StatusCode: 404,
			Body:       nil,
		}, nil
	}
	missingCVE := "CVE-2017-16099"
	testCVE := CVE{
		ID: missingCVE,
	}
	testCVEs := []CVE{testCVE}
	err := CheckRHCVE(0, testCVEs, "", "")
	if err != nil {
		t.Errorf("Got error trying to test missing dependency, %v", err)
	}
	if testCVE.RHKnown == true {
		t.Error("Expected Red Hat unknown state")
	}
}

//TODO fixme: comment test returns wrong result because cve.components goes back to nil after test call
func TestModuleAffects(t *testing.T) {
	var affectsTests = []struct {
		cve           string
		cpe           string
		packageName   string
		affectedState string
	}{
		{
			"CVE-2020-36189",
			"cpe:/a:redhat:quay:3::el7",
			"quay-registry-container",
			"",
		},
		/*{
			"CVE-2020-36189",
			"cpe:/a:redhat:openshift:4",
			"openshift4/ose-logging-elasticsearch5",
			"Will not fix",
		},*/
	}

	for _, tt := range affectsTests {
		testFile := "testdata/" + tt.cve + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		testCVE := CVE{
			ID: tt.cve,
		}
		testCVEs := []CVE{testCVE}
		testCVEs[0].MakeComponent(tt.cpe)
		err = CheckRHCVE(0, testCVEs, tt.cpe, tt.packageName)
		if err != nil {
			t.Errorf("Got error trying to test missing dependency, %v", err)
		}
		if testCVE.Components[tt.cpe].AffectedState != tt.affectedState {
			t.Errorf("Expected '%v' state but got '%v'\n", tt.affectedState, testCVE.Components[tt.cpe].AffectedState)
		}
	}
}

func TestGetContainerReposNonContainerNvr(t *testing.T) {
	nonContainerNvr := "some-nve-1"
	result, err := GetContainerRepos(nonContainerNvr)
	if err != nil {
		t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
	}
	if len(result) != 1 {
		t.Error("expected a slice with len 1")
	}
	if result[0] != nonContainerNvr {
		t.Errorf("expected unchanged nvr got %v", result[0])
	}
}

// TODO find an example of a build which has multiple repos for testings
func TestGetContainerRepos(t *testing.T) {
	var containerRepoTests = []struct {
		nvr   string
		repos []string
	}{
		{
			"quay-registry-container-v3.4.3-1",
			[]string{"quay/quay-rhel8"},
		},
	}
	for _, tt := range containerRepoTests {
		testFile := "testdata/" + tt.nvr + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		result, err := GetContainerRepos(tt.nvr)
		if err != nil {
			t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
		}
		if len(result) == 1 && len(tt.repos) == 1 {
			if result[0] != tt.repos[0] {
				t.Errorf("expected 1 repo with value %v, but got %v", tt.repos[0], result[0])
			}
		}
	}
}

func TestBugzillaComment(t *testing.T) {
	var bzCommentTests = []struct {
		bzId      string
		bzResults string
		expected  string
	}{
		{
			"1608153",
			`{"bugs":{"1608153":{"comments":[{"is_private":false,"count":5,"attachment_id":null,"creator":"jshepherd","time":"2021-03-19T06:20:50Z","bug_id":1608153,"tags":[],"text":"Statement:\n\nRed Hat Quay imports nodejs-crypttiles as a development dependency. Reducing the impact of Red Hat Quay to low.","id":14887281,"creation_time":"2021-03-19T06:20:50Z","creator_id":302723}]}},"comments":{}}`,
			"Red Hat Quay imports nodejs-crypttiles as a development dependency. Reducing the impact of Red Hat Quay to low.",
		},
	}

	for _, tt := range bzCommentTests {
		r := ioutil.NopCloser(bytes.NewReader([]byte(tt.bzResults)))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		testCves := []CVE{
			CVE{
				BugzillaID: "1608153",
			},
		}
		GetStatement(0, testCves)
		if testCves[0].Statement != tt.expected {
			t.Errorf("Got unexpected statement %v, expected %v", testCves[0].Statement, tt.expected)
		}
	}
}
