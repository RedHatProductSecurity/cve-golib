package rhcve

import (
	"bufio"
	"io/ioutil"
	"net/http"
	"os"
	"testing"
)

// MockClient is the mock client
type MockClient struct {
	DoFunc func(req *http.Request) (*http.Response, error)
}

var (
	// GetDoFunc fetches the mock client's `Do` func
	GetDoFunc func(req *http.Request) (*http.Response, error)
)

// Do is the mock client's `Do` func
func (m *MockClient) Do(req *http.Request) (*http.Response, error) {
	return GetDoFunc(req)
}

func init() {
	Client = &MockClient{}
}

func TestMissingRHCVE(t *testing.T) {
	GetDoFunc = func(*http.Request) (*http.Response, error) {
		return &http.Response{
			StatusCode: 404,
			Body:       nil,
		}, nil
	}
	missingCVE := "CVE-2017-16099"
	testCVE := CVE{
		ID: missingCVE,
	}
	testCVEs := []CVE{testCVE}
	err := CheckRHCVE(0, testCVEs, "", "")
	if err != nil {
		t.Errorf("Got error trying to test missing dependency, %v", err)
	}
	if testCVE.RHKnown == true {
		t.Error("Expected Red Hat unknown state")
	}
}

func TestMitigation(t *testing.T) {
	var affectsTests = []struct {
		cve        string
		mitigation string
	}{
		{
			"CVE-2020-36189",
			"The following conditions are needed for an exploit, we recommend avoiding all if possible:",
		},
		{
			"CVE-2021-20305",
			"",
		},
	}

	for _, tt := range affectsTests {
		testFile := "testdata/" + tt.cve + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		testCVE := CVE{
			ID: tt.cve,
		}
		testCVEs := []CVE{testCVE}
		_ = CheckRHCVE(0, testCVEs, "", "")
		if testCVEs[0].Mitigation != tt.mitigation {
			t.Errorf("Expected statement: %v, got %v", tt.mitigation, testCVEs[0].Statement)
		}
	}
}

func TestModuleAffects(t *testing.T) {
	var affectsTests = []struct {
		cve             string
		cpe             string
		packageName     string
		affectedState   string
		impact          string
		componentImpact string
	}{
		{
			"CVE-2020-36189",
			"cpe:/a:redhat:quay:3::el7",
			"quay-registry-container",
			"",
			"important",
			"",
		},
		{
			"CVE-2020-36189",
			"cpe:/a:redhat:openshift:4",
			"openshift4/ose-logging-elasticsearch5",
			"Will not fix",
			"important",
			"moderate",
		},
		{
			"CVE-2021-20305",
			"cpe:/a:redhat:quay:3::el7",
			"quay-registry-container",
			"",
			"important",
			"",
		},
		{
			"CVE-2019-10744",
			"cpe:/a:redhat:rhel_software_collections:3",
			"rh-nodejs10-nodejs",
			"Not affected",
			"important",
			"low",
		},
	}

	for _, tt := range affectsTests {
		testFile := "testdata/" + tt.cve + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		testCVE := CVE{
			ID: tt.cve,
		}
		testCVEs := []CVE{testCVE}
		err = CheckRHCVE(0, testCVEs, tt.cpe, tt.packageName)
		if err != nil {
			t.Errorf("Got error trying to test missing dependency, %v", err)
		}
		if testCVEs[0].Components[tt.cpe].AffectedState != tt.affectedState {
			t.Errorf("Expected '%v' state but got '%v'\n", tt.affectedState, testCVEs[0].Components[tt.cpe].AffectedState)
		}
		if testCVEs[0].RHImpact.Name != tt.impact {
			t.Errorf("Expected '%v' impact but got '%v'\n", tt.impact, testCVEs[0].RHImpact.Name)
		}
		if testCVEs[0].Components[tt.cpe].Impact.Name != tt.componentImpact {
			t.Errorf("Expected '%v' state but got '%v'\n", tt.componentImpact, testCVEs[0].Components[tt.cpe].Impact.Name)
		}
	}
}

func TestGetContainerReposNonContainerNvr(t *testing.T) {
	nonContainerNvr := "some-nve-1"
	result, err := GetContainerRepos(nonContainerNvr)
	if err != nil {
		t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
	}
	if len(result) != 1 {
		t.Error("expected a slice with len 1")
	}
	if result[0] != nonContainerNvr {
		t.Errorf("expected unchanged nvr got %v", result[0])
	}
}

// TODO find an example of a build which has multiple repos for testings
func TestGetContainerRepos(t *testing.T) {
	var containerRepoTests = []struct {
		nvr   string
		repos []string
	}{
		{
			"quay-registry-container-v3.4.3-1",
			[]string{"quay/quay-rhel8"},
		},
		{
			"jaeger-query-rhel7-container-1.17.2-3",
			[]string{"distributed-tracing/jaeger-query-rhel7"},
		},
	}
	for _, tt := range containerRepoTests {
		testFile := "testdata/" + tt.nvr + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		result, err := GetContainerRepos(tt.nvr)
		if err != nil {
			t.Errorf("unexpected error returned from getContainerRepos call: %v", err)
		}
		if len(result) == 1 && len(tt.repos) == 1 {
			if result[0] != tt.repos[0] {
				t.Errorf("expected 1 repo with value %v, but got %v", tt.repos[0], result[0])
			}
		}
	}
}

func TestGetContainerProductName(t *testing.T) {
	var containerRepoTests = []struct {
		repo        string
		testData    string
		productName string
	}{
		{
			"quay/quay-rhel8",
			"quayProductListings",
			"Red Hat Quay",
		},
		{
			"distributed-tracing/jaeger-query-rhel7",
			"jaegerQueryProductListings",
			"Red Hat OpenShift Jaeger",
		},
	}
	for _, tt := range containerRepoTests {
		testFile := "testdata/" + tt.testData + ".json"
		f, err := os.Open(testFile)
		if err != nil {
			t.Errorf("Got error reading test data: %v\n", testFile)
		}
		r := ioutil.NopCloser(bufio.NewReader(f))
		GetDoFunc = func(*http.Request) (*http.Response, error) {
			return &http.Response{
				StatusCode: 200,
				Body:       r,
			}, nil
		}
		result, err := GetContainerProductName(tt.repo)
		if err != nil {
			t.Errorf("unexpected error returned from getContainerProductName call: %v", err)
		}
		if result != tt.productName {
			t.Errorf("expected '%v' but got '%v'", tt.productName, result)
		}
	}
}
